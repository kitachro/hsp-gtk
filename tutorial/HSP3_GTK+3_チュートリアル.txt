# この文書について

バージョン:
: 1.0

最終更新日:
: 2014年　月　日

ライセンス:
: GNU Free Documentation License 1.3 with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts

　この文書は、HSP3でGTK+3アプリケーションを書く方法を学ぶためのチュートリアルです。HSP3についてはひととおりの知識がある人を対象としています。

　このチュートリアルは、GTK+3でもっとも重要なクラスやメソッドについては説明していますが、APIリファレスではありません。APIの詳細な説明は[GTK+ 3 Reference Manual](http://developer.gnome.org/gtk3/stable/)で確認して下さい。

　この文書は、[The Python GTK+ 3 Tutorial](http://python-gtk-3-tutorial.readthedocs.org/en/latest/index.html)のページの内容、および[https://github.com/sebp/PyGObject-Tutorial](https://github.com/sebp/PyGObject-Tutorial)にあるデータをベースに作成しました。

# 目次

## 1. 開発環境の準備
### 1.1. GTK+3の入手とインストール
### 1.2. コールバック関数実装プラグインの入手とインストール
## 2. はじめの一歩
### 2.1. もっともシンプルなGTK+3プログラム
### 2.2. ウィンドウにButtonウィジェットを配置する
## 3. GTK+3の基礎
### 3.1. メインループとシグナル
### 3.2. ウィジェットのプロパティ
## 4. 文字列について
## 5. レイアウトコンテナ
## 6. ラベル（Label）
## 7. エントリ（Entry）
## 8. ボタン（Button）
## 9. プログレスバー（ProgressBar）
## 10. スピナー（Spinner）
## 11. ツリービューとリストビュー（TreeView）
## 12. セルレンダラ（CellRenderer）
## 13. コンボボックス（ComboBox）
## 14. アイコンビュー（IconView）
## 15. テキストエディタ（TextView）
## 16. メニュー（Menu）
## 17. ダイアログ（Dialog）
## 18. クリップボード（Clipboard）
## 19. ドラッグアンドドロップ
## 20. GladeインターフェースデザイナーとGtkBuilderクラス
## 21. オブジェクト
## 22. ストックアイテム（StockItem）

==========

# 3. GTK+の基礎

　この章では、GTK+において特に重要な2つの概念について説明します。

## 3.1. メインループとシグナル

　他の多くのGUIツールキットと同じく、GTK+はイベント駆動のプログラミングモデルを採用しています。プログラムのユーザーが何もしていない時には、メインループがただ繰り返され、GTK+はユーザーの入力を待っているだけですが、ひとたびユーザーによって何らかの操作が行われると、メインループがそれを感知してGTK+にイベント（event）が送られます。

　イベントはそれが起こったウィジェット（widget。GTK+が提供するプログラム部品。例えばWindowやButton）に伝えられ、ウィジェットはイベントの種類に応じてひとつ以上のシグナル（signal）を発生させます。プログラムはシグナルによって「何かが起こった」ことを知ることができ、そのシグナルに関連付けられた（connectされた）関数があればそれを実行します。この関数のことをコールバック（callback）関数といいます。

　この「コールバック関数」という名前は、C言語（や同じ機能が使えるその他の言語）の言語機能に着目した場合の呼び方です。GTK+を利用したプログラム内での役割に着目した場合は、シグナルハンドラ（signal handler）と呼ばれます。

　コールバック関数では通常、シグナルの種類（＝プログラムで何が起こったか）に応じた処理を行います。例えば、ファイルを開くためのボタン（Button）が押された（clicked）のであれば、ファイル選択ダイアログ（FileChooserDialog）を表示したいと思うことが多いでしょう。必要な処理を行った後、コールバック関数がreturnされると、再びメインループに戻り、GTK+は待機状態になります。

　次に、コールバック関数のシグナルへの関連付け（connect）について、スクリプトの書式を挙げて説明します。

    g_signal_connect widget, "signal", varptr( callback ), varptr( data )

　関連付けは`g_signal_connect`関数で行います。

　引数について説明すると、`widget`には作成済みのウィジェットのインスタンスを指定します。ウィジェットのインスタンスとは、ウィジェットを作成する関数の戻り値です。

　`"signal"`は関連付けしたいシグナルの名前です。シグナル名は、その元となるイベントを表すものになっていることが多いです。起こるイベント（＝受け取れるシグナル）はウィジェットごとにあらかじめ決まっており、例えばボタン（Button）ウィジェットであれば、clickedシグナルに関数をconnectする場合が圧倒的に多いでしょう。clickedシグナルは、ウィジェットがクリックされた時に発生します。

　`callback`は、コールバック関数実装プラグインhscallbk.dllのsetcallbk命令の引数に指定したコールバック型の変数です。hscallbk.dllを使用した場合、コールバック関数はラベルで始まりreturn命令で終わることになりますが、既に説明した通り、このラベルとreturnの間に、イベントが起こった時に実行したい処理を記述します。

　`data`には、コールバック関数を呼び出す時に引数として渡したいテータが入った変数をひとつ指定できます。コールバック関数内で受け取る時点ではポインタになっていますので注意してください。このポインタは2番目の引数として受け取ることができます。特に渡したいテータがない場合には、`varptr( data )`の代わりに`0`を指定してください。

　つづいて、シグナルとコールバック関数の関連付けを削除する方法について説明します。

    g_signal_connect widget, "signal", varptr( callback ), varptr( data )
    handler_id = stat
    
    g_signal_handler_disconnect widget, handler_id

　先に説明したg_signal_connect関数の戻り値が関連付けの識別番号になっていますので、その値を引数としてg_signal_handler_disconnect関数を実行することによって、関連付けを削除することができます。g_signal_handler_disconnectを実行した時点で識別番号は無効になります。

　何らかの理由で関連付けの識別番号を利用できない場合は、g_signal_handlers_disconnect_matchedという関数で、例えば、特定のコールバック関数への関連付けをすべて削除するなどといったこともできます。詳しくは[GTK+ 3 Reference Manual](http://developer.gnome.org/gtk3/stable/)などを参考にしてください。

　最後に、GTK+におけるシグナルとコールバック関数（シグナルハンドラ）のよくある利用例について説明して、この節を終わります。

　たいていのGTK+アプリケーションは、トップレベルウィンドウのdestroyシグナルに、gtk_main_quit関数を呼び出す処理を含むシグナルハンドラをconnectしています。destroyシグナルは、プログラムのユーザーがウィンドウを閉じようとした時に発生するdelete-eventシグナルのハンドラでウィンドウを閉じることがキャンセルされなかった場合に、自動的に発生するシグナルです。

　プログラマが上記のようなdestroyシグナルのハンドラをconnectするのには理由があり、原因はdestroyシグナルのデフォルトのハンドラの仕様にあります。デフォルトハンドラとは、プログラマが明示的にconnectするハンドラとは別に、文字通りデフォルトでconnectされているハンドラのことです。

　このdestroyシグナルのデフォルトハンドラ内では、トップレベルウィンドウが破棄される（＝メモリ上から削除され、プログラムのユーザーはもちろんプログラマからも利用できなくなる）のですが、ハンドラを抜けた後も、プログラムのメインループは回り続けます。

　つまり、プログラムが動き続けるにもかかわらず、プログラムのユーザーがプログラムを終了する手段がなくなってしまうということです。そこでこれを防ぐために、メインループから抜けるためのgtk_main_quit関数を呼び出すシグナルハンドラをconnectする必要があるというわけです。gtk_main_quit関数を呼び出す責任はプログラマにあります。

　gtk_main_quit関数によってメインループを抜けると、プログラムの実行位置はgtk_main関数の呼び出しの直後に戻ります。通常その後ろにはHSPのend命令を書いてプログラムを終了させます。

## 3.2. ウィジェットのプロパティ

==========

