# この文書について

公開者:
: chrono (<https://github.com/kitachro>)

バージョン:
: 0.5.1

最終更新日:
: 2014年11月20
日

ライセンス（Copyright）:
: GNU Free Documentation License 1.3 with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts

　この文書は、HSP3でGTK+3アプリケーションを書く方法を学ぶためのチュートリアルです。既にHSPが使える人向けです。

　このチュートリアルは、[The Python GTK+ 3 Tutorial](http://python-gtk-3-tutorial.readthedocs.org/en/latest/index.html)のサイトをベースに作成しました。著者は、Sebastian Polsterl氏、dharmatech氏、Tshepang Lekhonkhobe氏、Jim Zhang氏、vaporup氏、以下の方々です。正確な著者情報については、随時変化しているため、<https://github.com/sebp/PyGObject-Tutorial>のサイトにて確認して下さい。

　この文書の透過的複製物は<https://github.com/kitachro/hsp-gtk>にて公開しています。

====================
# 1. 開発環境の準備

====================
## 1.1. GTK+3の入手とインストール

　このチュートリアルでは、[The GTK+ Project](http://www.gtk.org/)で公開されているall-in-one bundleアーカイブのGTK+3を動作確認に利用しています。ダウンロードは、Downloadのページからリンクされている、32bitもしくは64bit Windows用アーカイブのページで行えます。アーカイブはただのzipファイルなので、ダウンロード後、解凍してください。

　アーカイブに含まれるファイルの中で、HSPスクリプトのデバッグ実行、およびスクリプトから作った実行ファイルの動作に必ず必要なのは、binフォルダにあるDLLファイルです。まずはデバッグ実行用に、これらのDLLファイルをすべて、HSP用プラグインを使う時と同じようにHSPのインストールフォルダにコピーしてください。

　実行ファイルの動作に必要なDLLは、スクリプトから利用しているものとそれらが依存しているDLLになります。DLLの依存関係を調べるには、Dependency Walkerというフリーウェアが便利です。Dependency Walkerは、他にもDLLに含まれている関数名を表示したり、その一覧をクリップボードにコピーできたりするのでおすすめです。ただしDependency Walkerを使わなくても、エラーなしで実行ファイルが起動するかどうかでDLLがそろっているかどうかを確認できます。

　なお、アーカイブフォルダ以下の、"\share\gtk-doc\html"フォルダに英語のマニュアルが収録されていますので、プログラミングの参考にしてください。このマニュアルは、基本的に[GNOME 開発センター](https://developer.gnome.org/)のサイトにあるAPIリファレンスと同じものですが、アーカイブのバージョンに合った情報が載っています。

　このチュートリアルを読むにあたっては、"\share\gtk-doc\html\gtk3\api-index-full.html"のページを開いておくと、関数の仕様などを簡単に調べることができて便利です。

　また、以上で説明した以外のファイルもプログラミングに役立ちますので、捨てずに、アーカイブのフォルダごと任意の場所に移動しておいてください。さらにこれらのファイル内のテキストを一気に全文検索できるソフトウェアを用意しておくと、プログラミングが捗ります。

====================
## 1.2. コールバック関数実装プラグインの入手

　HSPからGTK+を利用するには、HSPでコールバック関数という機能を使えるようにする必要があるのですが、これを実現してくれるのが、ちょくとさんによって公開されているHSP拡張プラグインのhscallbk.dllです。

　hscallbk.dllは、[ちょくとのページ](http://chokuto.ifdef.jp/index.html)内のダウンロードのページでダウンロードできます。非常に簡単に使えますので、Readmeを読んで把握しておいてください。

====================
# 2. GTK+の基礎

　この章では、GTK+において特に重要な、「ウィジェットのプロパティ」と「メインループとシグナル」という2つの概念について説明します。

　この章で挙げているスクリプトの断片は、それだけで実行することはできません。プログラムとして動作するサンプルスクリプトは、3章で挙げています。

====================
## 2.1. ウィジェットのプロパティ

　GTK+のウィジェット（widget。GTK+が提供するプログラム部品。例えば、WindowやButton）は、インスタンス（プログラム上で生成済みのウィジェット）ごとにプロパティというものを持っています。プロパティは、インスタンスの内部情報や状態を表し、ウィジェットの種類ごとにどんなプロパティを持つかが決まっています。例えば、Buttonウィジェットであれば、ボタン上に表示される文字列を表すlabelプロパティを持っています。

　プロパティの値を設定・取得するには、プロパティごとに用意されている設定・取得用関数を実行します。例えば、Buttonウィジェットであれば、gtk_button_set_label、gtk_button_get_label関数によって、labelプロパティの値を設定・取得することができます。

====================
### 2.1.1. ウィジェットのプロパティを設定する

********************
    gtk_button_new
	button = stat
    gtk_button_set_label button, "text"
********************

　gtk_button_set_label関数の引数には、Buttonウィジェットのインスタンス（ウィジェット生成関数（gtk_button_new）の戻り値がその値です）と、ラベルに設定したい文字列（または文字列へのポインタ）を指定します。

====================
### 2.1.2. ウィジェットのプロパティを取得する

********************
    gtk_button_get_label button
    ptr = stat
********************

　gtk_button_get_label関数の引数には、Buttonウィジェットのインスタンスを指定します。そして、gtk_button_get_label関数の戻り値がラベル文字列へのポインタになっていますので、それをそのまま他の処理に利用したり、HSPのdupptr命令でHSPで利用できる文字列変数に変換したりすることができます。

====================
### 2.1.3. ウィジェットの生成時にプロパティを設定する

　ウィジェットのプロパティのうちのいくつかは、ウィジェットの生成時に値を設定することができます。例えば、Buttonウィジェットであれば、gtk_button_newの代わりにgtk_button_new_with_label関数を使うことによって、単にボタンを生成するだけでなく、関数の引数を介して、ボタン上のラベルテキストを設定することができます。

********************
    gtk_button_new_with_label "Click!"
********************

　gtk_button_new_with_label関数を使う場合には、引数にボタンに表示したい文字列（または文字列へのポインタ）を指定します。生成されたウィジェットが戻り値として返されるのは、gtk_button_new関数と同じです。

====================
## 2.2. メインループとシグナル

====================
### 2.2.1. GTK+アプリケーションの基本構造

　他の多くのGUIツールキットと同じく、GTK+はイベント駆動のプログラミングモデルを採用しています。プログラムのユーザが何もしていない時には、メインループ（ユーザの操作を待つための無限ループ）が繰り返され、GTK+はただ待機しているだけですが、ひとたびユーザによって何らかの操作が行われると、GTK+にイベント（event）が送られます。このイベントを待つという状態は、HSPのstop命令を実行した時と同じようなものです。

　イベントはそれが起こったウィジェットに伝えられ、ウィジェットはイベントの種類に応じて1つ以上のシグナル（signal）を発生させます。プログラムはシグナルによって「何かが起こった」ことを知ることができ、そのシグナルに関連付けられた（connectされた）関数があればそれを実行します。この関数のことをコールバック（callback）関数といいます。

　この「コールバック関数」という名前は、C言語（や同じ機能が使えるその他の言語）の言語機能に着目した場合の呼び方です。GTK+を利用したプログラム内での役割に着目した場合は、シグナルハンドラ（signal handler）と呼ばれます。

　コールバック関数では、通常シグナルの種類（＝プログラムで何が起こったか）に応じた処理を行います。例えば、ファイルを開くためのボタン（Button）が押された（clicked）のであれば、ファイル選択ダイアログ（FileChooserDialog）を表示したりすることが多いでしょう。必要な処理を行った後、コールバック関数がreturnされると、再びメインループに戻り、GTK+は待機状態になります。

====================
### 2.2.2. シグナルとコールバック関数を関連付ける

　次に、コールバック関数のシグナルへの関連付け（connect）について、スクリプトの書式を挙げて説明します。

********************
    g_signal_connect widget, "signal", varptr( callback ), varptr( data )
********************

　関連付けは`g_signal_connect`関数で行います。

　1つ目の引数の`widget`には、生成済みのウィジェット（インスタンス）を指定します。前節で説明したように、ウィジェットを生成する関数の戻り値（stat）がインスタンスを表す値になっていますので、それを利用します。

　次の`"signal"`は関連付けしたいシグナルの名前です。シグナル名は、その元となるイベントを表すものになっていることが多いです。起こるイベント（＝受け取れるシグナル）は、プロパティと同じようにウィジェットごとにあらかじめ決まっており、例えば、Buttonウィジェットであれば、clickedシグナルに関数をconnectする場合が圧倒的に多いでしょう。clickedシグナルは、ウィジェットがクリックされた時に発生します。

　`callback`は、コールバック関数実装プラグインhscallbk.dllのsetcallbk命令の引数に指定したコールバック型の変数です。hscallbk.dllを使用した場合、コールバック関数はラベルで始まりreturn命令で終わることになりますが、既に説明した通り、このラベルとreturnの間に、イベントが起こった時に実行したい処理を記述します。

　`data`には、コールバック関数を呼び出す時に引数として渡したいテータが入った変数を1つ指定できます。`g_signal_connect`関数には、そのポインタを渡します。このポインタは、コールバック関数の2番目の引数として受け取ることができます（一部、引数を利用できないコールバック関数もあります）。特に渡したいテータがない場合には、`varptr( data )`の代わりに`0`を指定してください。3章の2節で挙げているサンプルプログラムで、この引数の使用例を見ることができます。

====================
### 2.2.3. シグナルとコールバック関数の関連付けを削除する

　つづいて、シグナルとコールバック関数の関連付けを削除する方法について説明します。

********************
    g_signal_connect widget, "signal", varptr( callback ), varptr( data )
    handler_id = stat
    
    g_signal_handler_disconnect widget, handler_id
********************

　先に説明したg_signal_connect関数の戻り値が関連付けの識別番号になっていますので、その値を引数としてg_signal_handler_disconnect関数を実行することによって、関連付けを削除することができます。g_signal_handler_disconnectを実行した時点で識別番号は無効になります。

　何らかの理由で関連付けの識別番号を利用できない場合は、g_signal_handlers_disconnect_matchedという関数で、例えば、特定のコールバック関数への関連付けをすべて削除するなどといったことができます。詳しくは[GTK+ 3 Reference Manual](http://developer.gnome.org/gtk3/stable/)などを参考にしてください。

====================
### 2.2.4. シグナルとコールバック関数の使用例

　最後に、GTK+におけるシグナルとコールバック関数（シグナルハンドラ）のよくある使用例について説明して、この節を終わります。

　たいていのGTK+アプリケーションは、トップレベルウィンドウ（＝デスクトップ画面に単独で存在できるウィンドウ）のdelete-eventシグナルに、gtk_main_quit関数を呼び出す処理を含むシグナルハンドラをconnectしています。delete-eventシグナルは、プログラムのユーザがウィンドウを閉じようとした時、例えばクローズボタンを押した時などに発生するシグナルです。

　プログラマが上記のようなdelete-eventシグナルのハンドラをconnectするのには理由があり、原因はdelete-eventシグナルのデフォルトのハンドラの仕様にあります。デフォルトハンドラとは、プログラマが明示的にconnectするハンドラとは別に、文字通りデフォルトでconnectされているハンドラのことです。

　このdelete-eventシグナルのデフォルトハンドラ内では、トップレベルウィンドウが破棄される（＝メモリ上から削除され、プログラムのユーザはもちろんプログラマからも利用できなくなる）のですが、ハンドラを抜けた後もプログラムのメインループは回り続けます。

　つまり、プログラムが動き続けるにもかかわらず、プログラムのユーザがプログラムを終了する手段がなくなってしまうということです。そこでこれを防ぐために、メインループから抜けるためのgtk_main_quit関数を呼び出すシグナルハンドラをconnectする必要があるというわけです（ちなみにメインループに入るにはgtk_main関数を実行します）。gtk_main_quit関数を呼び出す責任はプログラマにあります。

　ただし、ユーザがトップレベルウィンドウを閉じようとした時でも、それをキャンセルしたい場合があります。その場合には、プログラマがconnectしたdelete-eventシグナルのハンドラで1を返すことによって、デフォルトハンドラの実行はキャンセルされ、ウィンドウは破棄されずにそのまま残ります。

　gtk_main_quit関数によってメインループを抜けると、プログラムの実行位置はgtk_main関数の呼び出しの直後に戻ります。通常その後ろにはHSPのend命令を書いてプログラムを終了させます。

====================
# 3. はじめの一歩

　この章では、ごくシンプルなサンプルプログラムのスクリプトを挙げて、それについて解説します。

====================
## 3.1. 最もシンプルなGTK+3プログラム

　まずは、できる限り短いGTK+3プログラムのスクリプトを示します。このスクリプトを実行すると、縦横200ピクセルの大きさの空のウィンドウが表示されます。ウィンドウを閉じると、プログラムは終了します。

====================
### 3.1.1. プログラムの全体

********************
    #include "hscallbk.as"
    #uselib ""
    #func cb_window_delete_event ""
    
    #uselib "libgtk-3-0.dll"
    #func global gtk_init "gtk_init" sptr, sptr
    #func global gtk_window_new "gtk_window_new" int
    #const	GTK_WINDOW_TOPLEVEL	0
    #func global gtk_widget_show_all "gtk_widget_show_all" sptr
    #func global gtk_main "gtk_main"
    #func global gtk_main_quit "gtk_main_quit"
    #uselib "libgobject-2.0-0.dll"
    #define g_signal_connect(%1, %2, %3, %4) g_signal_connect_data %1, %2, %3, %4, 0, 0
    #func global g_signal_connect_data "g_signal_connect_data" sptr, str, sptr, sptr, int, int
    
    	gtk_init	0, 0
    
    	gtk_window_new	GTK_WINDOW_TOPLEVEL
    	win	= stat
    	setcallbk	cbwindowdeleteevent, cb_window_delete_event, *on_window_delete_event
    	g_signal_connect	win, "delete-event", varptr( cbwindowdeleteevent ), 0
    
    	gtk_widget_show_all	win
    	gtk_main
    	end
    
    *on_window_delete_event
    	gtk_main_quit
    	return
********************

　以後、パートごとにスクリプトの内容について説明していきます。

====================
### 3.1.2. コールバック関数を使うための準備

********************
    #include "hscallbk.as"
    #uselib ""
    #func cb_window_delete_event ""
********************

　冒頭は、hscallbk.dllを利用してコールバック関数を使えるようにするためのスクリプトです。書き方については、hscallbk.dllのreadmeを参照してください。今回のプログラムでは、ウィンドウでdelete-eventシグナルが発生した時に実行する処理をコールバック関数として書く必要があるので、cb_window_delete_eventという名前を使っています。

====================
### 3.1.3. GTK+3の関数を使うための準備

********************
    #uselib "libgtk-3-0.dll"
    #func global gtk_init "gtk_init" sptr, sptr
    #func global gtk_window_new "gtk_window_new" int
    #const	GTK_WINDOW_TOPLEVEL	0
    #func global gtk_widget_show_all "gtk_widget_show_all" sptr
    #func global gtk_main "gtk_main"
    #func global gtk_main_quit "gtk_main_quit"
    #uselib "libgobject-2.0-0.dll"
    #define g_signal_connect(%1, %2, %3, %4) g_signal_connect_data %1, %2, %3, %4, 0, 0
    #func global g_signal_connect_data "g_signal_connect_data" sptr, str, sptr, sptr, int, int
********************

　この部分は、GTK+3のDLLの関数を使えるようにするためのスクリプトです。分量的に全体の半分近くを占める長さですが、他のプログラムでも再利用できる部分です。

　#uselib命令と#func命令の行は、HSPから一般的なDLLを利用するためのスクリプトとしてはありふれたものなので、その意味では難しいことはないと思います。DLLの関数を直接呼び出しますので、[GTK+ 3 Reference Manual](http://developer.gnome.org/gtk3/stable/)に載っている関数名がそのまま使えます。引数の型についても、リファレンスで調べて指定しています。

　#const命令と#define命令の行は、GTK+3のアーカイブに添付されているC言語用ヘッダファイルの内容をHSP向けに書き直したものです。

　GTK_WINDOW_TOPLEVEL定数は、[GTK+ 3 Reference Manual](http://developer.gnome.org/gtk3/stable/)には載っていますが値は書かれていないので、GTK+3のアーカイブ内のファイルを全文検索して定義を見つけました。値さえわかれば、マクロは絶対に必要なものではありませんが、毎度、調べたり思い出したりする手間を考えれば、（再利用することを前提に）書いておくのが得策です。

　g_signal_connect関数も、[GTK+ 3 Reference Manual](http://developer.gnome.org/gtk3/stable/)には載っていますが、DLLには実装されておらずマクロで定義されていたので、こちらもHSPで書き直してやる必要がありました。このマクロについても、g_signal_connect_data関数を使うのが面倒でなければ、省略してしまってもかまいませんが、まあ書いておいた方が楽かなと思います。

====================
### 3.1.4. GTK+の初期化

********************
	gtk_init	0, 0
********************

　ここまでの下準備的なスクリプトの後でまず行わなければいけないことは、gtk_init関数でGTK+を初期化することです。この関数を実行しておかないと、他のGTK+の関数はまともに動きません。

　gtk_init関数に渡す2つの引数は、C言語の場合であれば、main関数の引数として受け取ることができるargcとargvをそのまま渡してやればいいのですが、HSPの場合には、これらを簡単に取得する方法がないので、代わりに0を渡してください。

====================
### 3.1.5. ウィンドウの生成

********************
	gtk_window_new	GTK_WINDOW_TOPLEVEL
	win	= stat
********************

　GTK+で空のウィンドウを生成して、それを表す値を変数に保存しています。

====================
### 3.1.6. ウィンドウのシグナルとコールバック関数の関連付け

********************
	setcallbk	cbwindowdeleteevent, cb_window_delete_event, *on_window_delete_event
	g_signal_connect	win, "delete-event", varptr( cbwindowdeleteevent ), 0
********************

　hscallbk.dllのsetcallbk命令で、*on_window_delete_eventラベルで始まるサブルーチンをコールバック関数として呼び出せるようにした上で、g_signal_connect関数を実行して、Windowウィジェットのdelete-eventシグナルに関連付け（connect）しています。

====================
### 3.1.7. ウィンドウの表示

********************
	gtk_widget_show_all	win
********************

　gtk_widget_show_all関数は生成済みのウィジェット（ここではウィンドウ）を画面に表示します。

====================
### 3.1.8. メインループの開始

********************
	gtk_main
	end
********************

　ウィンドウの生成、シグナルとそれに対する処理の関連付け、ウィンドウの表示、が終わったら、gtk_main関数でメインループに入ってユーザの操作を待ちます。GTK+では、gtk_mainを抜けたらプログラムを終了させるのが普通なので、そのすぐ後ろにend命令を書いておきます。

====================
### 3.1.9. コールバック関数（シグナルハンドラ）の定義

********************
    *on_window_delete_event
    	gtk_main_quit
    	return
********************

　最後は、g_signal_connect関数でdelete-eventシグナルに関連付けしたサブルーチンです。gtk_main_quit関数を実行すると、メインループから抜けてgtk_main関数からreturnすることができます。

====================
## 3.2. ウィンドウにウィジェットを1つ配置する

　つづいて、もう1つ、トップレベルウィンドウにウィジェットを1つ置いてそれを動作させるプログラムを挙げます。

====================
### 3.2.1. プログラムの全体

********************
    #include "hscallbk.as"
    #uselib ""
    #func cb_window_delete_event ""
    #func cb_button_clicked "" int, int
    
    #uselib "libgtk-3-0.dll"
    #func global gtk_init "gtk_init" sptr, sptr
    #func global gtk_window_new "gtk_window_new" int
    #const	GTK_WINDOW_TOPLEVEL	0
    #func global gtk_widget_show_all "gtk_widget_show_all" sptr
    #func global gtk_main "gtk_main"
    #func global gtk_main_quit "gtk_main_quit"
    #func global gtk_button_new_with_label "gtk_button_new_with_label" sptr
    #func global gtk_container_add "gtk_container_add" sptr, sptr
    #uselib "libgobject-2.0-0.dll"
    #define g_signal_connect(%1, %2, %3, %4) g_signal_connect_data %1, %2, %3, %4, 0, 0
    #func global g_signal_connect_data "g_signal_connect_data" sptr, str, sptr, sptr, int, int
    ;#func global g_signal_handler_disconnect "g_signal_handler_disconnect" sptr, int 
    ;#func global g_signal_handlers_disconnect_matched "g_signal_handlers_disconnect_matched" sptr, int, int, int, sptr, sptr, sptr
    ;#const	G_SIGNAL_MATCH_FUNC	(1 << 3)
    
    	gtk_init	0, 0
    
    	gtk_window_new	GTK_WINDOW_TOPLEVEL
    	win	= stat
    	setcallbk	cbwindowdeleteevent, cb_window_delete_event, *on_window_delete_event
    	g_signal_connect	win, "delete-event", varptr( cbwindowdeleteevent ), 0
    
    	gtk_button_new_with_label	"Click Here"
    	btn	= stat
    	setcallbk	cbbuttonclicked, cb_button_clicked, *on_button_clicked
    	msg = "Hello World"
    	g_signal_connect	btn, "clicked", varptr( cbbuttonclicked ), varptr( msg )
    ;id = stat
    ;g_signal_handler_disconnect btn, id
    ;g_signal_handlers_disconnect_matched btn, G_SIGNAL_MATCH_FUNC, 0, 0, 0, varptr( cbbuttonclicked ), 0
    
    	gtk_container_add	win, btn
    	gtk_widget_show_all	win
    	gtk_main
    	end
    
    *on_window_delete_event
    	gtk_main_quit
    	return
    
    *on_button_clicked
    	dupptr	cbdata, callbkarg( 1 ), 20, 2
    	mes		cbdata
    	return
********************

　以後、前節と同じように各パートの説明になりますが、前節と2章で既に説明した内容は省略します。

====================
### 3.2.2. コメントアウト部分

********************
    ;#func global g_signal_handler_disconnect "g_signal_handler_disconnect" sptr, int 
    ;#func global g_signal_handlers_disconnect_matched "g_signal_handlers_disconnect_matched" sptr, int, int, int, sptr, sptr, sptr
    ;#const	G_SIGNAL_MATCH_FUNC	(1 << 3)
    
    （中略）
    
    ;id = stat
    ;g_signal_handler_disconnect btn, id
    ;g_signal_handlers_disconnect_matched btn, G_SIGNAL_MATCH_FUNC, 0, 0, 0, varptr( cbbuttonclicked ), 0
********************

　まず、スクリプトの中でコメントアウトされている部分ですが、これは、2章で説明した、シグナルとコールバック関数の関連付けを削除するためのスクリプトです。動作を確認したい場合に適宜有効にして実行してください。

====================
### 3.2.3. コールバック関数を介したデータの受け渡し

********************
    	msg = "Hello World"
    	g_signal_connect	btn, "clicked", varptr( cbbuttonclicked ), varptr( msg )
    
    （中略）
    
    *on_button_clicked
    	dupptr	cbdata, callbkarg( 1 ), 20, 2
    	mes		cbdata
    	return
********************

　上記は、生成したボタンに対して、clickedシグナルとコールバック関数を関連付けている処理と、コールバック関数本体の部分です。2章で説明した、コールバック関数の引数を介してデータを受け渡しする例になっています。

　ここでは、コールバック関数の引数として文字列変数のポインタを受け取っています。ポインタなので、HSPで中身のデータを扱うには、dupptr命令でそのポインタが指す変数を作ってやる必要があります。dupptr命令では、3番目の引数として「クローン元のメモリサイズ」を指定しますが、今回の例では、g_signal_connect関数の引数に指定した変数のサイズになります。ただし文字列変数の場合は、ある程度大きな数値を指定してしまっても大丈夫なようです。

　実際、HSPでわざわざコールバック関数の引数を介してデータをやりとりする必要がどれだけあるかはわかりませんが、g_signal_connect関数の機能の一部として説明しました。ちなみに、コールバック関数の1番目の引数には、シグナルが発生したウィジェットインスタンスが代入されています。

====================
### 3.2.4. ウィンドウへのウィジェットの追加

********************
    gtk_container_add	win, btn
********************

　最後に、ウィンドウにボタンを追加している部分について説明します。

　GTK+のWindowウィジェットに他のウィジェットを子として追加するには、gtk_container_add関数を使います。2つのウィジェットのインスタンスを引数として指定します。

　Windowウィジェットに複数のウィジェットを詰め込む方法については5章で説明します。

====================
# 4. HSPからGTK+を利用する際の、文字コードに関する注意点

====================
## 4.1 GTK+とやりとりする文字列の文字コードについて

　まず1つ目の注意点は、GTK+は基本的にUTF-8エンコーディングの文字列しか扱えない、ということです。これはつまり、GTK+の関数に渡す文字列は、必ずUTF-8エンコードされていなければならず、また、GTK+の関数から返される文字列は、UTF-8エンコードされたものとして扱う必要がある、ということです。

====================
## 4.2 HSPスクリプトの保存文字コードについて

　2つ目の注意点は、GTK+がUTF-8しか受け付けないからといって、HSPスクリプトファイルの保存文字コードをUTF-8にしてはいけない、ということです。標準エディタを使っている人は、そのような心配はないとは思いますが、いずれにしても、UTF-8エンコードされたマルチバイト文字（日本語の文字など）を含むHSPスクリプトは、エラーが出て実行できません。HSPスクリプトファイルは、シフトJISで保存されている必要があります。

====================
## 4.3 HSPプログラム内での対処方法

　そこでどうすれば良いかというと、必要に応じて、随時プログラム内で変換します。

　1つの手段としては、HSPに標準で添付されている拡張プラグインのhspinet.dllにあるnkfcnv命令を使うといいでしょう。

例えば、""で囲まれる形で、HSPのスクリプト上に直接書かれている文字列は、そのままでは当然シフトJISエンコーディングなので、nkfcnv命令でUTF-8エンコーディングに変換した上でGTK+の関数に渡します。

********************
    sjis_text = "クリック！"
    nkfcnv	utf8_text, sjis_text, "Sw"
    gtk_button_new_with_label	utf8_text
********************

　このサンプルでは、DLLを使うための準備は省略していますが、手順は理解できると思います。ただし、このようなスクリプトを毎回書くのは面倒なので、モジュール内にごく短い名前のユーザ定義関数を作って、変換処理はその中に書いておき、変換が必要になる度にその関数を呼び出す形にすると、手間を減らすことができます。

********************
    #module
    	/* shift-jis文字列をutf-8に変換 */
    #defcfunc u str chars_
    	chars	= chars_
    	nkfcnv@	chars, chars, "Sw"
    	return	chars
    #global
    
        gtk_button_new_with_label	u( "クリック！" )
********************

====================
# 5. レイアウトコンテナ

　この章では、GTK+でウィンドウ（Window）に複数のウィジェットを配置する方法を説明します。

　ご存じの通り、HSP本来の機能では、オブジェクト（GUI部品）は、配置する数にかかわらず、プログラマが1つ1つ固定した座標を指定してウィンドウに配置します。

　一方GTK+では、複数のウィジェットをウィンドウに配置する場合、一定のパターンに沿って半自動的に配置する機能を持った、レイアウト専用のウィジェットを使います。この種のウィジェットをレイアウトコンテナ（Layout Container）と呼びます。まず、このレイアウトコンテナをウィンドウに載せ、さらにその上に、プログラムのユーザが操作するウィジェットを並べる、という形になります。レイアウトコンテナを利用すると、ピクセル単位の座標で指定するよりも、非常に簡便に配置をコントロールできます。

　GTK+には、様々な種類のレイアウトコンテナが用意されており、それぞれ、「縦または横方向に一直線に配置する」、「タイル形に配置する」、「すべて同じ位置に配置し、1度に1つだけ表示する」など、様々な配置パターンを持っています。さらに、レイアウトコンテナ同士を入れ子にして組み合わせることもできます。

　この章では、それらのうち、ボックス（HBoxおよびVBox）とテーブル（Table）を取り上げます。

====================
## 5.1. ボックス（HBoxおよびVBox）

====================
## 5.2. テーブル（Table）

====================
# 6. ラベル（Label）

====================
# 7. エントリ（Entry）

====================
# 8. ボタン（Button）

====================
# 9. プログレスバー（ProgressBar）

====================
# 10. スピナー（Spinner）

====================
# 11. ツリービューとリストビュー（TreeView）

====================
# 12. セルレンダラ（CellRenderer）

====================
# 13. コンボボックス（ComboBox）

====================
# 14. アイコンビュー（IconView）

====================
# 15. テキストエディタ（TextView）

====================
# 16. メニュー（Menu）

====================
# 17. ダイアログ（Dialog）

====================
# 18. クリップボード（Clipboard）

====================
# 19. ドラッグアンドドロップ

====================
# 20. GladeインターフェースデザイナーとGtkBuilderクラス

====================
# 21. オブジェクト

====================
# 22. ストックアイテム（StockItem）



====================
目次

# 1. 開発環境の準備
## 1.1. GTK+3の入手とインストール
## 1.2. コールバック関数実装プラグインの入手
# 2. GTK+の基礎
## 2.1. ウィジェットのプロパティ
### 2.1.1. ウィジェットのプロパティを設定する
### 2.1.2. ウィジェットのプロパティを取得する
### 2.1.3. ウィジェットの生成時にプロパティを設定する
## 2.2. メインループとシグナル
### 2.2.1. GTK+アプリケーションの基本構造
### 2.2.2. シグナルとコールバック関数を関連付けする
### 2.2.3. シグナルとコールバック関数の関連付けを削除する
### 2.2.4. シグナルとコールバック関数の使用例
# 3. はじめの一歩
## 3.1. 最もシンプルなGTK+3プログラム
### 3.1.1. プログラムの全体
### 3.1.2. コールバック関数を使うための準備
### 3.1.3. GTK+3の関数を使うための準備
### 3.1.4. GTK+の初期化
### 3.1.5. ウィンドウの生成
### 3.1.6. ウィンドウのシグナルとコールバック関数を関連付ける
### 3.1.7. ウィンドウを画面に表示する
### 3.1.8. メインループの開始
### 3.1.9. コールバック関数（シグナルハンドラ）の定義
## 3.2. ウィンドウにウィジェットを1つ配置する
### 3.2.1. プログラムの全体
### 3.2.2. コメントアウト部分
### 3.2.3. コールバック関数を介したデータの受け渡し
### 3.2.4. ウィンドウへのウィジェットの追加
# 4. HSPからGTK+を利用する際の、文字コードに関する注意点
## 4.1 GTK+とやりとりする文字列の文字コードについて
## 4.2 HSPスクリプトの保存文字コードについて
## 4.3 HSPプログラム内での対処方法
# 5. レイアウトコンテナ
## 5.1. ボックス（HBoxおよびVBox）
## 5.2. テーブル（Table）
# 6. ラベル（Label）
# 7. エントリ（Entry）
# 8. ボタン（Button）
# 9. プログレスバー（ProgressBar）
# 10. スピナー（Spinner）
# 11. ツリービューとリストビュー（TreeView）
# 12. セルレンダラ（CellRenderer）
# 13. コンボボックス（ComboBox）
# 14. アイコンビュー（IconView）
# 15. テキストエディタ（TextView）
# 16. メニュー（Menu）
# 17. ダイアログ（Dialog）
# 18. クリップボード（Clipboard）
# 19. ドラッグアンドドロップ
# 20. GladeインターフェースデザイナーとGtkBuilderクラス
# 21. オブジェクト
# 22. ストックアイテム（StockItem）
