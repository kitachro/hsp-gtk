# この文書について

バージョン:
: 0.3.1

最終更新日:
: 2014年11月11日

ライセンス（Copyright）:
: GNU Free Documentation License 1.3 with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts

　この文書は、HSP3でGTK+3アプリケーションを書く方法を学ぶためのチュートリアルです。主に、既にHSPが使える人向けのものです。

　このチュートリアルは、GTK+3でもっとも重要なクラスや関数については説明していますが、APIリファレスではありません。APIの詳細については[GTK+ 3 Reference Manual](http://developer.gnome.org/gtk3/stable/)で確認して下さい。

　この文書は、[The Python GTK+ 3 Tutorial](http://python-gtk-3-tutorial.readthedocs.org/en/latest/index.html)のページをベースに作成しました。

# 目次

## 1. 開発環境の準備
### 1.1. GTK+3の入手とインストール
### 1.2. コールバック関数実装プラグインの入手
## 2. GTK+の基礎
### 2.1. ウィジェットのプロパティ
### 2.2. メインループとシグナル
## 3. はじめの一歩
### 3.1. もっともシンプルなGTK+3プログラム
### 3.2. ウィンドウにButtonウィジェットを配置する
## 4. 文字列について
## 5. レイアウトコンテナ
## 6. ラベル（Label）
## 7. エントリ（Entry）
## 8. ボタン（Button）
## 9. プログレスバー（ProgressBar）
## 10. スピナー（Spinner）
## 11. ツリービューとリストビュー（TreeView）
## 12. セルレンダラ（CellRenderer）
## 13. コンボボックス（ComboBox）
## 14. アイコンビュー（IconView）
## 15. テキストエディタ（TextView）
## 16. メニュー（Menu）
## 17. ダイアログ（Dialog）
## 18. クリップボード（Clipboard）
## 19. ドラッグアンドドロップ
## 20. GladeインターフェースデザイナーとGtkBuilderクラス
## 21. オブジェクト
## 22. ストックアイテム（StockItem）

==========

# 1. 開発環境の準備

## 1.1. GTK+3の入手とインストール

　このチュートリアルでは、[The GTK+ Project](http://www.gtk.org/)で公開されているall-in-one bundleアーカイブのGTK+3を動作確認に利用しています。ダウンロードは、Downloadのページからリンクされている、32bitもしくは64bit Windows用アーカイブのページで行えます。アーカイブはただのzipファイルなので、ダウンロード後、解凍してください。

　アーカイブに含まれるファイルの中で、HSPスクリプトのデバッグ実行、およびスクリプトから作った実行ファイルの動作に必ず必要なのは、binフォルダにあるDLLファイルです。まずはデバッグ実行用に、これらのDLLファイルをすべて、HSP用プラグインを使う時と同じようにHSPのインストールフォルダにコピーしてください。

　実行ファイルの動作に必要なDLLは、スクリプトから利用しているものとそれらが依存しているDLLになります。DLLの依存関係を調べるには、Dependency Walkerというフリーウェアが便利です。Dependency Walkerは、他にもDLLに含まれている関数名を表示したり、その一覧をクリップボードにコピーできたりするのでおすすめです。ただしDependency Walkerを使わなくても、エラーなしで実行ファイルが起動するかどうかでDLLがそろっているかどうかを確認できます。

　また、GTK+3のアーカイブのDLL以外のファイルもプログラミングに役立ちますので、捨てずにアーカイブのフォルダごと任意の場所に移動しておいてください。さらにこれらのファイル内のテキストを一気に全文検索できるソフトウェアを用意しておくと、プログラミングが捗ります。

## 1.2. コールバック関数実装プラグインの入手

　HSPからGTK+を利用するには、HSPでコールバック関数という機能を使えるようにする必要があるのですが、これを実現してくれるのが、ちょくとさんによって公開されているHSP拡張プラグインのhscallbk.dllです。

　hscallbk.dllは、[ちょくとのページ](http://chokuto.ifdef.jp/index.html)内のダウンロードのページでダウンロードできます。非常に簡単に使えますので、Readmeを読んで把握しておいてください。

==========

# 2. GTK+の基礎

　この章では、GTK+において特に重要な2つの概念について説明します。

## 2.1. ウィジェットのプロパティ

　GTK+のウィジェット（widget。GTK+が提供するプログラム部品。例えば、WindowやButton）は、インスタンス（プログラム上で作成済みのウィジェット）ごとにプロパティというものを持っています。プロパティは、インスタンスの内部情報や状態を表し、ウィジェットの種類ごとにどんなプロパティを持つかが決まっています。例えば、Buttonウィジェットであれば、ボタン上に表示される文字列を表すlabelプロパティを持っています。

　プロパティの値を設定・取得するには、プロパティごとに用意されている設定・取得用関数を実行します。例えば、Buttonウィジェットであれば、gtk_button_set_label、gtk_button_get_label関数によって、labelプロパティの値を設定・取得することができます。

    gtk_button_new
	button = stat
    gtk_button_set_label button, "text"

　gtk_button_set_label関数の引数には、Buttonウィジェットのインスタンス（ウィジェット作成関数（gtk_button_new）の戻り値がその値です）と、ラベルに設定したい文字列（または文字列へのポインタ）を指定します。

    gtk_button_get_label button
    ptr = stat

　gtk_button_get_label関数の引数には、Buttonウィジェットのインスタンスを指定します。そして、gtk_button_get_label関数の戻り値がラベル文字列へのポインタになっていますので、それをそのまま他の処理に利用したり、HSPのdupptr命令でHSPで利用できる文字列変数に変換したりすることができます。

　さらにウィジェットのプロパティのうちのいくつかは、ウィジェットの作成時に値を設定することができます。例えば、Buttonウィジェットであれば、gtk_button_newの代わりにgtk_button_new_with_label関数を使うことによって、単にボタンを作成するだけでなく、関数の引数を介して、ボタン上のラベルテキストを設定することができます。

    gtk_button_new_with_label "Click!"

　gtk_button_new_with_label関数を使う場合には、引数にボタンに表示したい文字列（または文字列へのポインタ）を指定します。作成されたウィジェットが戻り値として返されるのは、gtk_button_new関数と同じです。

## 2.2. メインループとシグナル

　他の多くのGUIツールキットと同じく、GTK+はイベント駆動のプログラミングモデルを採用しています。プログラムのユーザが何もしていない時には、メインループ（ユーザの操作を待つための無限ループ）が繰り返され、GTK+はただ待機しているだけですが、ひとたびユーザによって何らかの操作が行われると、GTK+にイベント（event）が送られます。このイベントを待つという状態は、HSPのstop命令を実行した時と同じようなものです。

　イベントはそれが起こったウィジェットに伝えられ、ウィジェットはイベントの種類に応じて一つ以上のシグナル（signal）を発生させます。プログラムはシグナルによって「何かが起こった」ことを知ることができ、そのシグナルに関連付けられた（connectされた）関数があればそれを実行します。この関数のことをコールバック（callback）関数といいます。

　この「コールバック関数」という名前は、C言語（や同じ機能が使えるその他の言語）の言語機能に着目した場合の呼び方です。GTK+を利用したプログラム内での役割に着目した場合は、シグナルハンドラ（signal handler）と呼ばれます。

　コールバック関数では通常、シグナルの種類（＝プログラムで何が起こったか）に応じた処理を行います。例えば、ファイルを開くためのボタン（Button）が押された（clicked）のであれば、ファイル選択ダイアログ（FileChooserDialog）を表示したいと思うことが多いでしょう。必要な処理を行った後、コールバック関数がreturnされると、再びメインループに戻り、GTK+は待機状態になります。

　次に、コールバック関数のシグナルへの関連付け（connect）について、スクリプトの書式を挙げて説明します。

    g_signal_connect widget, "signal", varptr( callback ), varptr( data )

　関連付けは`g_signal_connect`関数で行います。

　一つ目の引数の`widget`には、作成済みのウィジェット（インスタンス）を指定します。前節で説明したように、ウィジェットを作成する関数の戻り値（stat）がインスタンスを表す値になっていますので、それを利用します。

　次の`"signal"`は関連付けしたいシグナルの名前です。シグナル名は、その元となるイベントを表すものになっていることが多いです。起こるイベント（＝受け取れるシグナル）は、プロパティと同じようにウィジェットごとにあらかじめ決まっており、例えばボタン（Button）ウィジェットであれば、clickedシグナルに関数をconnectする場合が圧倒的に多いでしょう。clickedシグナルは、ウィジェットがクリックされた時に発生します。

　`callback`は、コールバック関数実装プラグインhscallbk.dllのsetcallbk命令の引数に指定したコールバック型の変数です。hscallbk.dllを使用した場合、コールバック関数はラベルで始まりreturn命令で終わることになりますが、既に説明した通り、このラベルとreturnの間に、イベントが起こった時に実行したい処理を記述します。

　`data`には、コールバック関数を呼び出す時に引数として渡したいテータが入った変数を一つ指定できます。コールバック関数内で受け取る時点ではポインタになっていますので注意してください。このポインタは2番目の引数として受け取ることができます。特に渡したいテータがない場合には、`varptr( data )`の代わりに`0`を指定してください。

　つづいて、シグナルとコールバック関数の関連付けを削除する方法について説明します。

    g_signal_connect widget, "signal", varptr( callback ), varptr( data )
    handler_id = stat
    
    g_signal_handler_disconnect widget, handler_id

　先に説明したg_signal_connect関数の戻り値が関連付けの識別番号になっていますので、その値を引数としてg_signal_handler_disconnect関数を実行することによって、関連付けを削除することができます。g_signal_handler_disconnectを実行した時点で識別番号は無効になります。

　何らかの理由で関連付けの識別番号を利用できない場合は、g_signal_handlers_disconnect_matchedという関数で、例えば、特定のコールバック関数への関連付けをすべて削除するなどといったこともできます。詳しくは[GTK+ 3 Reference Manual](http://developer.gnome.org/gtk3/stable/)などを参考にしてください。

　最後に、GTK+におけるシグナルとコールバック関数（シグナルハンドラ）のよくある利用例について説明して、この節を終わります。

　たいていのGTK+アプリケーションは、トップレベルウィンドウのdelete-eventシグナルに、gtk_main_quit関数を呼び出す処理を含むシグナルハンドラをconnectしています。delete-eventシグナルは、プログラムのユーザがウィンドウを閉じようとした時、例えばクローズボタンを押した時などに発生するシグナルです。

　プログラマが上記のようなdelete-eventシグナルのハンドラをconnectするのには理由があり、原因はdelete-eventシグナルのデフォルトのハンドラの仕様にあります。デフォルトハンドラとは、プログラマが明示的にconnectするハンドラとは別に、文字通りデフォルトでconnectされているハンドラのことです。

　このdelete-eventシグナルのデフォルトハンドラ内では、トップレベルウィンドウが破棄される（＝メモリ上から削除され、プログラムのユーザはもちろんプログラマからも利用できなくなる）のですが、ハンドラを抜けた後もプログラムのメインループは回り続けます。

　つまり、プログラムが動き続けるにもかかわらず、プログラムのユーザがプログラムを終了する手段がなくなってしまうということです。そこでこれを防ぐために、メインループから抜けるためのgtk_main_quit関数を呼び出すシグナルハンドラをconnectする必要があるというわけです（ちなみにメインループに入るにはgtk_main関数を実行します）。gtk_main_quit関数を呼び出す責任はプログラマにあります。

　ただし、ユーザがトップレベルウィンドウを閉じようとした時でも、それをキャンセルしたい場合があります。その場合には、プログラマがconnectしたdelete-eventシグナルのハンドラで1を返すことによって、デフォルトハンドラの実行はキャンセルされ、ウィンドウは破棄されずにそのまま残ります。

　gtk_main_quit関数によってメインループを抜けると、プログラムの実行位置はgtk_main関数の呼び出しの直後に戻ります。通常その後ろにはHSPのend命令を書いてプログラムを終了させます。

==========

# 3. はじめの一歩

　この章では、ごくシンプルなサンプルプログラムのスクリプトを挙げて、それについて解説します。

## 3.1. もっともシンプルなGTK+3プログラム

　まずは、できる限り短いGTK+3プログラムのスクリプトを示します。このスクリプトを実行すると、縦横200ピクセルの大きさの空のウィンドウが表示されます。ウィンドウを閉じると、プログラムは終了します。

    #include "hscallbk.as"
    #uselib ""
    #func cb_window_delete_event ""
    
    #uselib "libgtk-3-0.dll"
    #func global gtk_init "gtk_init" sptr, sptr
    #func global gtk_window_new "gtk_window_new" int
    #const	GTK_WINDOW_TOPLEVEL	0
    #func global gtk_widget_show_all "gtk_widget_show_all" sptr
    #func global gtk_main "gtk_main"
    #func global gtk_main_quit "gtk_main_quit"
    #uselib "libgobject-2.0-0.dll"
    #define g_signal_connect(%1, %2, %3, %4) g_signal_connect_data %1, %2, %3, %4, 0, 0
    #func global g_signal_connect_data "g_signal_connect_data" sptr, str, sptr, sptr, int, int
    
    	gtk_init	0, 0
    
    	gtk_window_new	GTK_WINDOW_TOPLEVEL
    	win	= stat
    	setcallbk	cbwindowdeleteevent, cb_window_delete_event, *on_window_delete_event
    	g_signal_connect	win, "delete-event", varptr( cbwindowdeleteevent ), 0
    
    	gtk_widget_show_all	win
    	gtk_main
    	end
    
    *on_window_delete_event
    	gtk_main_quit
    	return

　以後、パートごとにスクリプトの内容について説明していきます。

    #include "hscallbk.as"
    #uselib ""
    #func cb_window_delete_event ""

　冒頭は、hscallbk.dllを利用してコールバック関数を使えるようにするためのコードです。書き方については、hscallbk.dllのreadmeを参照してください。今回のプログラムでは、ウィンドウでdelete-eventシグナルが発生した時に実行する処理をコールバック関数として書く必要があるので、cb_window_delete_eventという名前を使っています。

    #uselib "libgtk-3-0.dll"
    #func global gtk_init "gtk_init" sptr, sptr
    #func global gtk_window_new "gtk_window_new" int
    #const	GTK_WINDOW_TOPLEVEL	0
    #func global gtk_widget_show_all "gtk_widget_show_all" sptr
    #func global gtk_main "gtk_main"
    #func global gtk_main_quit "gtk_main_quit"
    #uselib "libgobject-2.0-0.dll"
    #define g_signal_connect(%1, %2, %3, %4) g_signal_connect_data %1, %2, %3, %4, 0, 0
    #func global g_signal_connect_data "g_signal_connect_data" sptr, str, sptr, sptr, int, int

　この部分は、GTK+3を構成するDLLの関数を使えるようにするためのコードです。分量的に全体の半分近くを占める長さですが、他のプログラムでも再利用できる部分です。

　#uselib命令と#func命令の行は、HSPから一般的なDLLを利用するためのコードとしてはありふれたものなので、その意味では難しいことはないと思います。DLLの関数を直接呼び出しますので、[GTK+ 3 Reference Manual](http://developer.gnome.org/gtk3/stable/)に載っている関数名がそのまま使えます。引数の型についても、リファレンスで調べて指定しています。

　#const命令と#define命令の行は、GTK+3のアーカイブに添付されているC言語用ヘッダファイルの内容をHSP向けに書き直したものです。

　GTK_WINDOW_TOPLEVEL定数は、[GTK+ 3 Reference Manual](http://developer.gnome.org/gtk3/stable/)には載っていますが値は書かれていないので、アーカイブ内のファイルを全文検索して定義を見つけました。値さえわかれば、マクロは絶対に必要なものではありませんが、毎度、調べたり思い出したりする手間を考えれば、（再利用することを前提に）書いておくのが得策です。

　g_signal_connect関数は、こちらも[GTK+ 3 Reference Manual](http://developer.gnome.org/gtk3/stable/)には載っていますが、DLLには実装されておらずマクロで定義されていたので、こちらもHSPで書き直してやる必要がありました。このマクロについても、g_signal_connect_data関数を使うのが面倒でなければ、省略してしまってもかまいませんが、まあ書いておいた方がいいのではないかと思います。

	gtk_init	0, 0

　ここまでの下準備的なコードの後でまず行わなければいけないことは、gtk_init関数でGTK+を初期化することです。この関数を実行しておかないと、他のGTK+の関数はまともに動きません。

　もし本番のプログラミングで、再利用するためのコードを分離したヘッダファイル的なものを使うのであれば、この関数呼び出しはそちらに入れてしまってもいいかもしれません。

　gtk_init関数に渡す2つの引数は、C言語の場合であれば、main関数の引数として受け取ることができるargcとargvをそのまま渡してやればいいのですが、HSPの場合には、これらを簡単に取得する方法がないので、代わりに0を渡してください。

	gtk_window_new	GTK_WINDOW_TOPLEVEL
	win	= stat

　GTK+で空のウィンドウを生成して、それを表す値を変数に保存しています。

	setcallbk	cbwindowdeleteevent, cb_window_delete_event, *on_window_delete_event
	g_signal_connect	win, "delete-event", varptr( cbwindowdeleteevent ), 0

　hscallbk.dllのsetcallbk命令で、*on_window_delete_eventラベルで始まるサブルーチンをコールバック関数として呼び出せるようにした上で、g_signal_connect関数で、サブルーチンをGTK+のdelete-eventシグナルに関連付け（connect）しています。

	gtk_widget_show_all	win

　gtk_widget_show_all関数は生成済みのウィジェット（ここではウィンドウ）を画面に表示します。

	gtk_main
	end

　ウィンドウの作成、シグナルとそれ対する処理の関連付け、ウィンドウの表示、が終わったら、gtk_main関数でメインループに入ってユーザの操作を待ちます。GTK+では、gtk_mainを抜けたらプログラムを終了させるのが普通なので、そのすぐ後ろにend命令を書いておきます。

    *on_window_delete_event
    	gtk_main_quit
    	return

　最後は、g_signal_connect関数でdelete-eventシグナルに関連付けしたサブルーチンです。gtk_main_quit関数を実行すると、メインループから抜けてgtk_main関数からreturnすることができます。

## 3.2. ウィンドウにButtonウィジェットを配置する

==========

