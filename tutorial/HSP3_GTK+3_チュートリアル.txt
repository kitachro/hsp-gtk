# この文書について

バージョン:
: 1.0

最終更新日:
: 2014年　月　日

ライセンス:
: GNU Free Documentation License 1.3 with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts

　この文書は、HSP3でGTK+3アプリケーションを書く方法を学ぶためのチュートリアルです。主に、既にHSPが使える人向けのものになります。

　このチュートリアルは、GTK+3でもっとも重要なクラスやメソッドについては説明していますが、APIリファレスではありません。APIの詳細については[GTK+ 3 Reference Manual](http://developer.gnome.org/gtk3/stable/)で確認して下さい。

　この文書は、[The Python GTK+ 3 Tutorial](http://python-gtk-3-tutorial.readthedocs.org/en/latest/index.html)のページの内容、および[https://github.com/sebp/PyGObject-Tutorial](https://github.com/sebp/PyGObject-Tutorial)にあるデータをベースに作成しました。

# 目次

## 1. 開発環境の準備
### 1.1. GTK+3の入手とインストール
### 1.2. コールバック関数実装プラグインの入手とインストール
## 2. はじめの一歩
### 2.1. もっともシンプルなGTK+3プログラム
### 2.2. ウィンドウにButtonウィジェットを配置する
## 3. GTK+3の基礎
### 3.1. メインループとシグナル
### 3.2. ウィジェットのプロパティ
## 4. 文字列について
## 5. レイアウトコンテナ
## 6. ラベル（Label）
## 7. エントリ（Entry）
## 8. ボタン（Button）
## 9. プログレスバー（ProgressBar）
## 10. スピナー（Spinner）
## 11. ツリービューとリストビュー（TreeView）
## 12. セルレンダラ（CellRenderer）
## 13. コンボボックス（ComboBox）
## 14. アイコンビュー（IconView）
## 15. テキストエディタ（TextView）
## 16. メニュー（Menu）
## 17. ダイアログ（Dialog）
## 18. クリップボード（Clipboard）
## 19. ドラッグアンドドロップ
## 20. GladeインターフェースデザイナーとGtkBuilderクラス
## 21. オブジェクト
## 22. ストックアイテム（StockItem）

==========

# 1. 開発環境の準備

## 1.1. GTK+3の入手とインストール

　このチュートリアルでは、[The GTK+ Project](http://www.gtk.org/)で公開されているall-in-one bundleアーカイブのGTK+3を動作確認に利用しています。ダウンロードは、Downloadのページからリンクされている、32bitもしくは64bit Windows用アーカイブのページで行えます。アーカイブはただのzipファイルなので、ダウンロード後、解凍してください。

　アーカイブに含まれるファイルの中で、HSPスクリプトのデバッグ実行、およびスクリプトから作った実行ファイルの動作に必ず必要なのは、binフォルダにあるDLLファイルです。これらのDLLファイルをすべて、HSP用プラグインを使う時と同じようにHSPのインストールフォルダにコピーしてください。

　実行ファイルの動作に必要なDLLは、スクリプトから利用したものとそれらが依存しているDLLになります。DLLの依存関係を調べるには、Dependency Walkerというフリーウェアが便利です。Dependency Walkerは、他にもDLLに含まれている関数名を表示したり、その一覧をクリップボードにコピーできたりするのでおすすめです。

　また、GTK+3のアーカイブのDLL以外のファイルもプログラミングに役立ちますので、捨てずにアーカイブのフォルダごと任意の場所に移動しておいてください。さらにこれらのファイル内のテキストを一気に全文検索できるソフトウェアを用意しておくと、プログラミングが捗ると思います。

## 1.2. コールバック関数実装プラグインの入手とインストール

　HSPからGTK+を利用するには、HSPでコールバック関数という機能を使えるようにする必要があるのですが、これを実現してくれるのが、ちょくとさんによって公開されているHSP拡張プラグインのhscallbk.dllです。

　hscallbk.dllは、[ちょくとのページ](http://chokuto.ifdef.jp/index.html)内のダウンロードのページでダウンロードできます。非常に簡単に使えますので、インストール後、Readmeを読んで把握しておいてください。

==========

# 2. はじめの一歩

　この章では、ごくシンプルなサンプルプログラムのスクリプトを挙げて、それについて解説します。もしこの章の内容がわかりにくいと感じた場合は、次の章を読んだ後に再度読み直すと、より確実に理解できるでしょう。

## 2.1. もっともシンプルなGTK+3プログラム

　まずは、できる限りもっとも短いGTK+3プログラムのスクリプトを示します。このスクリプトを実行すると、縦横200ピクセルの大きさの空のウィンドウが表示されます。ウィンドウを閉じると、プログラムは終了します。

    #include "hscallbk.as"
    #uselib ""
    #func cb_window_delete_event ""
    
    #uselib "libgtk-3-0.dll"
    #func global gtk_init "gtk_init" sptr, sptr
    #func global gtk_window_new "gtk_window_new" int
    #const	GTK_WINDOW_TOPLEVEL	0
    #func global gtk_widget_show_all "gtk_widget_show_all" sptr
    #func global gtk_main "gtk_main"
    #func global gtk_main_quit "gtk_main_quit"
    #uselib "libgobject-2.0-0.dll"
    #define g_signal_connect(%1, %2, %3, %4) g_signal_connect_data %1, %2, %3, %4, 0, 0
    #func global g_signal_connect_data "g_signal_connect_data" sptr, str, sptr, sptr, int, int
    
    	gtk_init	0, 0
    
    	gtk_window_new	GTK_WINDOW_TOPLEVEL
    	win	= stat
    	setcallbk	cbwindowdeleteevent, cb_window_delete_event, *on_window_delete_event
    	g_signal_connect	win, "delete-event", varptr( cbwindowdeleteevent ), 0
    
    	gtk_widget_show_all	win
    	gtk_main
    	end
    
    *on_window_delete_event
    	gtk_main_quit
    	return

　以後、パートごとにスクリプトの内容について説明していきます。

    #include "hscallbk.as"
    #uselib ""
    #func cb_window_delete_event ""

　まず冒頭は、hscallbk.dllを利用してコールバック関数を使えるようにするためのコードです。書き方については、hscallbk.dllのreadmeを参照してください。今回のプログラムでは、ウィンドウでdelete-eventシグナルが発生した時に実行する処理をコールバック関数として書く必要があるので、cb_window_delete_eventという名前を使っています。

    #uselib "libgtk-3-0.dll"
    #func global gtk_init "gtk_init" sptr, sptr
    #func global gtk_window_new "gtk_window_new" int
    #const	GTK_WINDOW_TOPLEVEL	0
    #func global gtk_widget_show_all "gtk_widget_show_all" sptr
    #func global gtk_main "gtk_main"
    #func global gtk_main_quit "gtk_main_quit"
    #uselib "libgobject-2.0-0.dll"
    #define g_signal_connect(%1, %2, %3, %4) g_signal_connect_data %1, %2, %3, %4, 0, 0
    #func global g_signal_connect_data "g_signal_connect_data" sptr, str, sptr, sptr, int, int

　この部分は、GTK+3を構成するDLLの関数を使えるようにするためのコードです。分量的に全体の半分近くを占める長さですが、他のプログラムでも再利用できる部分です。

　#uselib命令と#func命令の行は、HSPから一般的なDLLを利用するためのコードとしてはありふれたものなので、その意味では難しいことはないと思います。DLLの関数を直接呼び出しますので、[GTK+ 3 Reference Manual](http://developer.gnome.org/gtk3/stable/)に載っている関数名がそのまま使えます。引数の型についても、リファレンスで調べて指定しています。

　#const命令と#define命令の行は、GTK+3のアーカイブに添付されているC言語用ヘッダファイルの内容をHSP向けに書き直したものです。

　GTK_WINDOW_TOPLEVEL定数は、リファレンスには載っていますが値は書かれていないので、アーカイブ内のファイルを全文検索して定義を見つけました。値さえわかれば、マクロは絶対に必要なものではありませんが、毎度、調べたり思い出したりする手間を考えれば、（再利用することを前提に）書いておくのが得策です。

　g_signal_connect関数は、こちらもリファレンスには載っていますが、DLLには実装されておらずマクロで定義されていたので、こちらもHSPで書き直してやる必要がありました。このマクロについても、g_signal_connect_data関数を使うのが面倒でなければ、省略してしまってもかまいませんが、まあ書いておいた方がいいのではないかと思います。

## 2.2. ウィンドウにButtonウィジェットを配置する

==========

# 3. GTK+の基礎

　この章では、GTK+において特に重要な2つの概念について説明します。

## 3.1. メインループとシグナル

　他の多くのGUIツールキットと同じく、GTK+はイベント駆動のプログラミングモデルを採用しています。プログラムのユーザが何もしていない時には、メインループがただ繰り返され、GTK+はユーザの入力を待っているだけですが、ひとたびユーザによって何らかの操作が行われると、メインループがそれを感知してGTK+にイベント（event）が送られます。

　イベントはそれが起こったウィジェット（widget。GTK+が提供するプログラム部品。例えばWindowやButton）に伝えられ、ウィジェットはイベントの種類に応じてひとつ以上のシグナル（signal）を発生させます。プログラムはシグナルによって「何かが起こった」ことを知ることができ、そのシグナルに関連付けられた（connectされた）関数があればそれを実行します。この関数のことをコールバック（callback）関数といいます。

　この「コールバック関数」という名前は、C言語（や同じ機能が使えるその他の言語）の言語機能に着目した場合の呼び方です。GTK+を利用したプログラム内での役割に着目した場合は、シグナルハンドラ（signal handler）と呼ばれます。

　コールバック関数では通常、シグナルの種類（＝プログラムで何が起こったか）に応じた処理を行います。例えば、ファイルを開くためのボタン（Button）が押された（clicked）のであれば、ファイル選択ダイアログ（FileChooserDialog）を表示したいと思うことが多いでしょう。必要な処理を行った後、コールバック関数がreturnされると、再びメインループに戻り、GTK+は待機状態になります。

　次に、コールバック関数のシグナルへの関連付け（connect）について、スクリプトの書式を挙げて説明します。

    g_signal_connect widget, "signal", varptr( callback ), varptr( data )

　関連付けは`g_signal_connect`関数で行います。

　ひとつ目の引数の`widget`には作成済みのウィジェットのインスタンスを指定します。ウィジェットのインスタンスとは、ウィジェットを作成する関数の戻り値（stat）です。

　次の`"signal"`は関連付けしたいシグナルの名前です。シグナル名は、その元となるイベントを表すものになっていることが多いです。起こるイベント（＝受け取れるシグナル）はウィジェットごとにあらかじめ決まっており、例えばボタン（Button）ウィジェットであれば、clickedシグナルに関数をconnectする場合が圧倒的に多いでしょう。clickedシグナルは、ウィジェットがクリックされた時に発生します。

　`callback`は、コールバック関数実装プラグインhscallbk.dllのsetcallbk命令の引数に指定したコールバック型の変数です。hscallbk.dllを使用した場合、コールバック関数はラベルで始まりreturn命令で終わることになりますが、既に説明した通り、このラベルとreturnの間に、イベントが起こった時に実行したい処理を記述します。

　`data`には、コールバック関数を呼び出す時に引数として渡したいテータが入った変数をひとつ指定できます。コールバック関数内で受け取る時点ではポインタになっていますので注意してください。このポインタは2番目の引数として受け取ることができます。特に渡したいテータがない場合には、`varptr( data )`の代わりに`0`を指定してください。

　つづいて、シグナルとコールバック関数の関連付けを削除する方法について説明します。

    g_signal_connect widget, "signal", varptr( callback ), varptr( data )
    handler_id = stat
    
    g_signal_handler_disconnect widget, handler_id

　先に説明したg_signal_connect関数の戻り値が関連付けの識別番号になっていますので、その値を引数としてg_signal_handler_disconnect関数を実行することによって、関連付けを削除することができます。g_signal_handler_disconnectを実行した時点で識別番号は無効になります。

　何らかの理由で関連付けの識別番号を利用できない場合は、g_signal_handlers_disconnect_matchedという関数で、例えば、特定のコールバック関数への関連付けをすべて削除するなどといったこともできます。詳しくは[GTK+ 3 Reference Manual](http://developer.gnome.org/gtk3/stable/)などを参考にしてください。

　最後に、GTK+におけるシグナルとコールバック関数（シグナルハンドラ）のよくある利用例について説明して、この節を終わります。

　たいていのGTK+アプリケーションは、トップレベルウィンドウのdelete-eventシグナルに、gtk_main_quit関数を呼び出す処理を含むシグナルハンドラをconnectしています。delete-eventシグナルは、プログラムのユーザがウィンドウを閉じようとした時に発生するシグナルです。

　プログラマが上記のようなdelete-eventシグナルのハンドラをconnectするのには理由があり、原因はdelete-eventシグナルのデフォルトのハンドラの仕様にあります。デフォルトハンドラとは、プログラマが明示的にconnectするハンドラとは別に、文字通りデフォルトでconnectされているハンドラのことです。

　このdelete-eventシグナルのデフォルトハンドラ内では、トップレベルウィンドウが破棄される（＝メモリ上から削除され、プログラムのユーザはもちろんプログラマからも利用できなくなる）のですが、ハンドラを抜けた後もプログラムのメインループは回り続けます。

　つまり、プログラムが動き続けるにもかかわらず、プログラムのユーザがプログラムを終了する手段がなくなってしまうということです。そこでこれを防ぐために、メインループから抜けるためのgtk_main_quit関数を呼び出すシグナルハンドラをconnectする必要があるというわけです（プログラマが独自のハンドラをconnectしても、デフォルトハンドラがなくなるわけではありません）。gtk_main_quit関数を呼び出す責任はプログラマにあります。

　gtk_main_quit関数によってメインループを抜けると、プログラムの実行位置はgtk_main関数の呼び出しの直後に戻ります。通常その後ろにはHSPのend命令を書いてプログラムを終了させます。

## 3.2. ウィジェットのプロパティ

==========

